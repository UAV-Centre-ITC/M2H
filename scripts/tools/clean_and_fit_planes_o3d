#!/usr/bin/env python3

import rospy
import ros_numpy
import open3d as o3d
import numpy as np
import threading
from sensor_msgs.msg import PointCloud2

class PointCloudCleaner:
    def __init__(self):
        # Initialize the ROS node
        rospy.init_node("pointcloud_cleaner")

        # Initialize the publisher for the cleaned point cloud
        self.pub = rospy.Publisher("/semantic_pointcloud", PointCloud2, queue_size=10)

        # Subscribe to the point cloud topic
        rospy.Subscriber("/semantic_pointcloud_org", PointCloud2, self.pointcloud_callback)

    def pointcloud_callback(self, msg):
        # Start a new thread for processing the point cloud
        threading.Thread(target=self.process_point_cloud_thread, args=(msg,)).start()

    def process_point_cloud_thread(self, msg):
        # Convert the PointCloud2 message to a NumPy structured array
        pc = ros_numpy.numpify(msg)
        pc = ros_numpy.point_cloud2.split_rgb_field(pc)  # Split the RGB field into separate channels

        # Extract points and flatten them
        points = np.zeros((pc.shape[0]*pc.shape[1], 3))
        points[:, 0] = pc['x'].flatten()  # Flatten to ensure it's 1D
        points[:, 1] = pc['y'].flatten()  # Flatten to ensure it's 1D
        points[:, 2] = pc['z'].flatten()  # Flatten to ensure it's 1D

        # Extract RGB values and normalize them
        rgb = np.zeros((pc.shape[0]*pc.shape[1], 3))
        rgb[:, 0] = pc['r'].flatten() / 255.0  # Red channel normalized
        rgb[:, 1] = pc['g'].flatten() / 255.0  # Green channel normalized
        rgb[:, 2] = pc['b'].flatten() / 255.0  # Blue channel normalized

        # Create an Open3D point cloud with points and colors
        pcd = o3d.geometry.PointCloud()
        pcd.points = o3d.utility.Vector3dVector(points)
        pcd.colors = o3d.utility.Vector3dVector(rgb)

        # Process the point cloud
        final_pcd = self.process_point_cloud(pcd)

        # Debugging output
        num_points = len(final_pcd.points)  # Changed to get the number of points correctly
        print(f"Number of points in final point cloud: {num_points}")

        # Ensure final_pcd is not empty
        if num_points == 0:
            rospy.logwarn("Final point cloud is empty. Not publishing.")
            return

        # Prepare structured array for PointCloud2
        final_points = np.asarray(final_pcd.points)
        final_colors = np.asarray(final_pcd.colors)

        # Create a structured array for ROS message
        data = np.zeros(final_points.shape[0], dtype=[
            ('x', np.float32),
            ('y', np.float32),
            ('z', np.float32),
            ('r', np.uint8),
            ('g', np.uint8),
            ('b', np.uint8)
        ])

        # Populate structured array
        data['x'] = final_points[:, 0]
        data['y'] = final_points[:, 1]
        data['z'] = final_points[:, 2]
        data['r'] = (final_colors[:, 0] * 255).astype(np.uint8)  # Scale and convert to uint8
        data['g'] = (final_colors[:, 1] * 255).astype(np.uint8)  # Scale and convert to uint8
        data['b'] = (final_colors[:, 2] * 255).astype(np.uint8)  # Scale and convert to uint8

        # Convert structured array to PointCloud2 message
        try:
            cleaned_msg = ros_numpy.msgify(PointCloud2, data, stamp=msg.header.stamp, frame_id=msg.header.frame_id)
            # Publish the cleaned point cloud
            self.pub.publish(cleaned_msg)
            # rospy.loginfo("Published cleaned point cloud.")
        except Exception as e:
            rospy.logerr(f"Error converting point cloud to ROS message: {e}")

    def process_point_cloud(self, pcd):
        if not pcd.has_colors():
            rospy.logwarn("Point cloud does not have colors.")
            return pcd  # Return original if no colors

        points = np.asarray(pcd.points)
        colors = np.asarray(pcd.colors)

        # Define height range (2m to 8m)
        mask = (points[:, 2] >= 2.0) & (points[:, 2] <= 8.0)

        # Filter points and colors
        filtered_points = points[mask]
        filtered_colors = colors[mask]

        # Define semantic class colors for filtering
        floor_color = np.array([191, 191, 181]) / 255.0  # Floor color normalized
        ceiling_color = np.array([59, 163, 236]) / 255.0  # Ceiling color normalized

        # Create masks for the floor and ceiling
        floor_mask = np.all(filtered_colors == floor_color, axis=1)
        ceiling_mask = np.all(filtered_colors == ceiling_color, axis=1)

        # Extract filtered points for floor and ceiling
        floor_points = filtered_points[floor_mask]
        ceiling_points = filtered_points[ceiling_mask]

        # Fit planes for floor and ceiling using RANSAC (if points exist)
        floor_plane_model = self.fit_plane(floor_points)
        ceiling_plane_model = self.fit_plane(ceiling_points)

        # Project floor and ceiling points onto their respective planes
        projected_floor_points = self.project_points_onto_plane(floor_points, floor_plane_model)
        projected_ceiling_points = self.project_points_onto_plane(ceiling_points, ceiling_plane_model)

        # Combine the remaining points and projected points
        remaining_points = filtered_points[~(floor_mask | ceiling_mask)]
        final_combined_points = np.vstack((remaining_points, projected_floor_points, projected_ceiling_points))
        final_combined_colors = np.vstack((filtered_colors[~(floor_mask | ceiling_mask)], filtered_colors[floor_mask], filtered_colors[ceiling_mask]))

        # Create the final point cloud
        final_pcd = o3d.geometry.PointCloud()
        final_pcd.points = o3d.utility.Vector3dVector(final_combined_points)
        final_pcd.colors = o3d.utility.Vector3dVector(final_combined_colors)

        return final_pcd

    def fit_plane(self, points):
        if len(points) == 0:
            return None
        pcd = o3d.geometry.PointCloud()
        pcd.points = o3d.utility.Vector3dVector(points)
        plane_model, _ = pcd.segment_plane(distance_threshold=0.05, ransac_n=3, num_iterations=100)
        return plane_model

    def project_points_onto_plane(self, points, plane_model):
        if plane_model is not None:
            a, b, c, d = plane_model
            distance = (a * points[:, 0] + b * points[:, 1] + c * points[:, 2] + d) / np.sqrt(a**2 + b**2 + c**2)
            projected_points = points - distance[:, np.newaxis] * np.array([a, b, c]) / np.sqrt(a**2 + b**2 + c**2)
            return projected_points
        return points  # Return original points if no model is available

def main():
    cleaner = PointCloudCleaner()
    rospy.spin()

if __name__ == '__main__':
    main()
